{"name":"Key Lime Box' Simple MQ","tagline":"A simple Message Queue with persistent subscribers.","body":"# Key Lime Box' Simple MQ\r\n\r\nWhy another Message Queue - because we needed something simple that does message \r\npublish/subscribe the way we wanted it. We looked at all the _established_ message \r\nqueue systems. They are good, but they are also very complex, handle many messaging\r\nneeds, etc.\r\n\r\nMost publish/subscribe model we found available were based on _connected subscribers_. We \r\nwanted persistent messages to subscribers whether connected or not.\r\n\r\n# Basic Architecture\r\n\r\nWe have a web server providing the REST API. This is a Spring Boot (Spring 4) based web \r\napplication.\r\n\r\nThe configuration of queues and persistence of messages and configuration is through \r\nMongoDB.\r\n\r\n## Operations\r\n\r\nWhen a message is published to a queue, Simple MQ looks at the queue's subscriber and creates\r\na queued message for each subscriber and persist them. If there are no subscriber to the \r\nqueue, no messages are queued.\r\n\r\n## Persistence\r\n\r\nIn this initial implementation, the persistence to MongoDB is done in a very simple way. \r\nThere is a collection named `messages` in which the `QueuedMessage`s are stored.\r\n\r\nEach `QueuedMessage` contains the ID of the queue they are for as well as the subscriber\r\nthey are for.\r\n\r\n### Idea of Improvement\r\n\r\nAn idea on how this could be improved would be to dynamically create collections for each\r\nqueue/subscriber pair. The advantages of doing it this way are:\r\n\r\n - Less overhead on the storage when reading queued messages - no lookup required to filter\r\n   the entries in the `messages` collection to those applicable to the queue/subscriber\r\n   requested.  \r\n\r\n - Adds flexibility to the management of the queues - one could define a queue/subscriber\r\n   collection to be a *circular buffer* so that even if the entries aren't read, the queue\r\n   does not grow indefinitely.\r\n\r\nThere are also some downside to this approach:\r\n\r\n - Harder to manage the state of the queue - you have to query each collections in the \r\n   storage to find how much entries they each have, if they have been there for too long,\r\n   etc. When using a single collection for all messages, one can just query with aggregates.\r\n\r\n - Can't use the Spring Data *repository* API and therefore require additional code for\r\n   the storage persistance.\r\n\r\n# REST API\r\n\r\n## Publishers\r\n\r\n### Viewing Existing Publishers\r\n\r\nGET `/api/publishers`\r\n\r\nReturns the list of existing publishers.\r\n\r\n### Registering a New Publisher\r\n\r\nPOST `/api/publishers/new`\r\n\r\nBefore publishing messages, the applications need to be registered as publisher. This is\r\na one-time action which is normally done during installation, not at runtime.\r\n\r\n\r\n## Subscribers\r\n\r\n### Listing the Subscribers\r\n\r\nGET `/api/subscribers`\r\n\r\nReturns the list of all registered subscribers.\r\n\r\n### Registering a New Subscriber\r\n\r\nPOST `/api/subscribers/new`\r\n\r\nBefore a subscriber can register with queues, it needs to be registered as a subscriber\r\nso it gets its own ID. \r\n\r\nThis is done by posting the following parameters to the above REST service:\r\n\r\n- `name`: A friendly name for this subscriber.\r\n\r\nThis is normally done only once when an application is deployed either manually or by the\r\nconfiguration management system. It is not something that generally gets put into the code\r\nof the subscriber application.\r\n\r\n\r\n\r\n## Queues\r\n\r\n### Listing the Queues\r\n\r\nGET `/api/queues`\r\n\r\nThis API call returns a list of the queues which exist.\r\n\r\n\r\n### Creating a Queue\r\n\r\nPOST `/api/queues/new`\r\n\r\nApplications that are going to be publishing messages must first create a queue. This is \r\na one-time action which is normally done during the deployment of the application (i.e.\r\nmanually or through a configuration management system, not necessarily in the application's\r\ncode).\r\n\r\nTo create a queue, post the following parameters:\r\n\r\n- `name`: A friendly queue name.\r\n- `description`: A longer description as to what this queue is for.\r\n\r\n\r\n### Subscribing to a Queue\r\n\r\nPOST `/api/queues/{queueId}/subscribe`\r\n\r\nTo subscribe to a queue, post the following parameters to this REST service:\r\n\r\n- `subscriber`: The ID of the subscriber.\r\n\r\n\r\n### Publishing a Message\r\n\r\nPOST `/api/queues/{queueId}/publish`\r\n\r\nA message can be published by posting a payload object (JSON) to this REST service with\r\nthe following parameters:\r\n\r\n- `publisher`: The ID of the publisher. \r\n\r\nA simple `String` payload can also be sent using a request parameter called `payload`, \r\nwhich is more convenient for payloads which consist of an ID for example.\r\n\r\n*Note*: if there are no subscriber to a queue, the messages published will not be \r\nrecorded.\r\n\r\n### Retrieving the Next Message\r\n\r\nGET `/api/queues/{queueId}/next`\r\n\r\nParameters:\r\n - `subscriber`: The ID of the subscriber to get the message for.\r\n - `previous`: (Optional) The ID of the previous message to be removed before getting the next one.\r\n\r\n# Monitoring\r\n\r\nA REST service is available for use with monitoring systems. At the moment, the *Nagios* \r\nformat is supported. A queue can be monitored by itself, or, a Subscriber ID can be \r\nsupplied to see the state of the queue as regards to that given subscriber.\r\n\r\nMonitoring a complete queue is not in itself very useful as it does not tell you which\r\nsubscriber stopped processing messages, but there may be some use-cases where this is \r\nneeded (for example, if you are going to have only 1 subscriber to a queue, then it is \r\none less parameter to pass).\r\n\r\nThe monitoring API is as follow:\r\n\r\nGET `/status/queues/{queueId}/?minutes={numberOfMinuteToWarn}&subscriber={subscriberId}&format=nagios`\r\n\r\n - `minutes`: Is a number of minutes after which a message in the queue is considered \r\n    stale and a warning should be issued.\r\n    \r\n - `subscriber`: (Optional) Is the ID of the subscriber you want to monitor in regards\r\n    to the given queue.\r\n    \r\n - `format`: (Optional - default to nagios) Is the format for the outpout. Only Nagios\r\n    format is currently supported.\r\n    \r\n## Queue Details\r\n\r\nThe API for the queues also has a status service returning detalis in `JSON` format as \r\nfollow:\r\n\r\nGET `/api/queues/{queueId}/status`\r\n\r\nParameters:\r\n\r\n - `subscriber`: (Optional) Is the ID of the subscriber you want to monitor in regards\r\n    to the given queue.\r\n\r\nThis can be convenient for manual inspection or for monitoring systems which can deal\r\nwith `JSON` format.    \r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}